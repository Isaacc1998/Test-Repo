{"version":3,"file":"main.js","mappings":"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","sources":["webpack://warfaretacticscopy/./src/scripts/atGunner.js","webpack://warfaretacticscopy/./src/scripts/levels.js","webpack://warfaretacticscopy/./src/scripts/player.js","webpack://warfaretacticscopy/./src/scripts/unit.js","webpack://warfaretacticscopy/webpack/bootstrap","webpack://warfaretacticscopy/webpack/runtime/global","webpack://warfaretacticscopy/webpack/runtime/publicPath","webpack://warfaretacticscopy/./assets/grass.png","webpack://warfaretacticscopy/./assets/dirt.png","webpack://warfaretacticscopy/./assets/crate1.png","webpack://warfaretacticscopy/./assets/rifle.png","webpack://warfaretacticscopy/./assets/grenade.png","webpack://warfaretacticscopy/./assets/sniper.png","webpack://warfaretacticscopy/./src/scripts/board.js"],"sourcesContent":["const Unit = require(\"./unit\").default;\n\nclass AtGunner extends Unit {\n  constructor(name, owner = null) {\n    super(\"atGunner\", 11, 8, 1, 3, 2);\n    this.name = name;\n    this.owner = owner;\n  }\n}\n\nmodule.exports = AtGunner;\n","module.exports = BATTLEFIELDS = {\n  levelOne: [\n    [0, 1, 1, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 1, 1, 0, 0],\n    [0, 3, 3, 3, 0, 0, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 1, 0, 0, 3, 3, 3, 0, 0],\n    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],\n    [0, 3, 3, 3, 0, 0, 1, 0, 0, 0],\n    [0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1],\n  ],\n\n  levelTwo: [\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  ],\n};\n","// import Levels from \"./level\";\nclass Player {\n  constructor(type) {\n    this.type = type;\n    this.playerUnits = [];\n  }\n\n  assignUnits(units) {\n    this.playerUnits.concat(units);\n  }\n}\n\nexport default Player;\n","class Unit {\n  constructor(type, health, attack, defense, range, move) {\n    this.type = type;\n    this.health = health;\n    this.attack = attack;\n    this.defense = defense;\n    this.range = range;\n    this.move = move;\n    this.alive = true;\n    this.items = [];\n    this.pos = [];\n    //ammo\n    //clip\n  }\n\n  setAlive(status) {\n    this.alive = status;\n  }\n\n  setPiece(pos) {\n    this.pos = pos;\n  }\n\n  move(newPos) {\n    this.pos = newPos;\n  }\n\n  giveItem(item) {\n    this.items.push(item);\n  }\n\n  isAlive() {\n    return this.alive;\n  }\n\n  takeDamage(dmg) {\n    console.log(\"damage\");\n    this.health = this.health - (dmg - this.defense);\n    if (this.health < 0) {\n      this.health = 0;\n    }\n    if (this.health === 0) {\n      this.alive = false;\n    }\n  }\n}\n\nexport default Unit;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","export default __webpack_public_path__ + \"d034f4a2c47c3c3068620d55db618d75.png\";","export default __webpack_public_path__ + \"0292f15a5491340be2c96175987a8688.png\";","export default __webpack_public_path__ + \"333aade2b420735d47a87dd3d53a9a5b.png\";","export default __webpack_public_path__ + \"2b352f91ad3be142bfce4bea52b5f365.png\";","export default __webpack_public_path__ + \"0584e2e99122dcec4480a418401ea098.png\";","export default __webpack_public_path__ + \"7c1edc51cc1dd9e0de4e2ae4c6c1db63.png\";","import Grass from \"../../assets/grass.png\";\nimport Dirt from \"../../assets/dirt.png\";\nimport Crate from \"../../assets/crate1.png\";\nimport Rifleman from \"../../assets/rifle.png\";\nimport Grenade from \"../../assets/grenade.png\";\nimport Sniper from \"../../assets/sniper.png\";\nconst Player = require(\"./player\").default;\nconst Unit = require(\"./unit\").default;\nconst Levels = require(\"./levels\").default;\nlet count = document.querySelector(\".tCount\");\nlet name = document.querySelector(\".name\");\nclass Board {\n  //edit\n  constructor(grid, playerUnits, enemyUnits) {\n    this.grid = grid;\n    //this.objectGrid = this.createObjectGrid();\n    this.units = playerUnits;\n    this.enemies = enemyUnits;\n    this.characterKey = {};\n    this.enemyNames = [];\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemyNames.push(this.enemies[i].name);\n    }\n    this.unitOrder = this.setTurnOrder();\n    for (let i = 0; i < this.unitOrder.length; i++) {\n      this.characterKey[this.unitOrder[i].name] = this.unitOrder[i];\n    }\n    // console.log(this.characterKey);\n    this.currentTurn = 0;\n    this.unitTurn = this.unitOrder[this.currentTurn % this.unitOrder.length];\n    this.unitGrid = new Array(10);\n    for (let i = 0; i < this.unitGrid.length; i++) {\n      this.unitGrid[i] = new Array(10);\n    }\n    for (let i = 0; i < this.unitGrid.length; i++) {\n      for (let j = 0; j < this.unitGrid[i].length; j++) {\n        this.unitGrid[i][j] = 0;\n      }\n    }\n    this.battlefield = this.drawBattlefield();\n    this.cellSize = 67;\n    this.padding = 2;\n    this.setPos();\n    this.tiles = [];\n    this.fillTiles();\n    this.unitImages = [];\n    this.generateUnitImages();\n    //this.unitContexts = this.createUnitCanvas();\n    this.generateHTMLsquares();\n    this.generateHTMLunits();\n    this.currentMoveCount = this.unitTurn.move;\n  }\n\n  setCurrentMoveCount() {\n    this.currentMoveCount = this.unitTurn.move;\n  }\n\n  attack(target) {\n    let attackedUnit = this.characterKey[target];\n    if (this.inRange(attackedUnit)) {\n      // console.log(\"before damge\");\n      attackedUnit.takeDamage(this.unitTurn.attack);\n      if (!attackedUnit.isAlive()) {\n        this.removeUnit(attackedUnit);\n      }\n    }\n  }\n\n  inRange(target) {\n    let range = this.unitTurn.range;\n    // console.log(target);\n    // console.log(this.unitTurn);\n    let xDif = target.pos[0] - this.unitTurn.pos[0];\n    let yDif = target.pos[1] - this.unitTurn.pos[1];\n    while (xDif !== 0) {\n      if (xDif > 0) {\n        xDif--;\n        range--;\n      } else if (xDif < 0) {\n        xDif++;\n        range--;\n      }\n    }\n\n    while (yDif !== 0) {\n      if (yDif > 0) {\n        yDif--;\n        range--;\n      } else if (yDif < 0) {\n        yDif++;\n        range--;\n      }\n    }\n    if (range < 0) {\n      return false;\n    }\n    return true;\n  }\n\n  findClickedUnit(name) {\n    // console.log(name);\n    for (let i = 0; i < this.unitOrder.length; i++) {\n      if (this.unitOrder[i].name === name) {\n        let alliance;\n        let type;\n        if (this.unitOrder[i].owner === null) {\n          alliance = \"Player 2\";\n        } else {\n          alliance = \"Player 1\";\n        }\n        if (this.unitOrder[i].type === \"atGunner\") {\n          type = \"RPG\";\n        } else {\n          type = this.unitOrder[i].type;\n        }\n        return [\n          this.unitOrder[i].health,\n          this.unitOrder[i].attack,\n          this.unitOrder[i].defense,\n          this.unitOrder[i].name,\n          type,\n          alliance,\n        ];\n      }\n    }\n  }\n\n  savePositions() {\n    for (let row = 0; row < this.unitGrid.length; row++) {\n      for (let col = 0; col < this.unitGrid[row].length; col++) {\n        if (this.unitGrid[row][col] instanceof Unit) {\n          let unitClick = document.getElementById(\n            `${this.unitGrid[row][col].name}`\n          );\n          unitClick.style.top = row * (this.cellSize + this.padding);\n          unitClick.style.left = col * (this.cellSize + this.padding);\n        }\n      }\n    }\n  }\n\n  generateUnitImages() {\n    let rifleman = new Image();\n    rifleman.src = Rifleman;\n    this.unitImages.push(rifleman);\n\n    let sniper = new Image();\n    sniper.src = Sniper;\n    this.unitImages.push(sniper);\n\n    let launcher = new Image();\n    launcher.src = Grenade;\n    this.unitImages.push(launcher);\n  }\n\n  fillTiles() {\n    let grass = new Image();\n    // grass.src = \"../assets/images/_0003_GrassTiles.png\";\n    grass.src = Grass;\n    this.tiles.push(grass);\n\n    let dirt = new Image();\n    // dirt.src = \"../tiles/Tiles/_0001_DirtTiles.png\";\n    dirt.src = Dirt;\n    this.tiles.push(dirt);\n\n    let crate = new Image();\n    // crate.src = \"../tiles/crates/TDS04_0018_Box1.png\";\n    crate.src = Crate;\n    this.tiles.push(crate);\n  }\n\n  setPos() {\n    for (let i = 0; i < this.units.length; i++) {\n      this.units[i].setPiece([0, i + 2]);\n      this.unitGrid[0][i + 2] = this.units[i];\n    }\n\n    for (let i = 0; i < this.enemies.length; i++) {\n      this.enemies[i].setPiece([this.unitGrid.length - 2, i + 4]);\n      this.unitGrid[this.unitGrid.length - 2][i + 4] = this.enemies[i];\n    }\n  }\n\n  isValidMove(x, y) {\n    if (\n      (this.grid[this.unitTurn.pos[0] + y][this.unitTurn.pos[1] + x] === 0 ||\n        this.grid[this.unitTurn.pos[0] + y][this.unitTurn.pos[1] + x] === 1) &&\n      this.unitGrid[this.unitTurn.pos[0] + y][this.unitTurn.pos[1] + x] === 0\n    ) {\n      return true;\n    }\n    //check starting position of units\n\n    return false;\n  }\n\n  updateGrid(x, y, value) {\n    this.unitGrid[x][y] = value;\n  }\n\n  moveunit = ({ keyCode }) => {\n    if (keyCode === 37) {\n      if (this.isValidMove(-1, 0)) {\n        this.updateGrid(this.unitTurn.pos[0], this.unitTurn.pos[1], 0);\n        this.updateGrid(\n          this.unitTurn.pos[0],\n          this.unitTurn.pos[1] - 1,\n          this.unitTurn\n        );\n        this.unitTurn.pos[1]--;\n        this.currentMoveCount--;\n      }\n    } else if (keyCode === 39) {\n      if (this.isValidMove(1, 0)) {\n        this.updateGrid(this.unitTurn.pos[0], this.unitTurn.pos[1], 0);\n        this.updateGrid(\n          this.unitTurn.pos[0],\n          this.unitTurn.pos[1] + 1,\n          this.unitTurn\n        );\n        this.unitTurn.pos[1]++;\n        this.currentMoveCount--;\n      }\n    } else if (keyCode === 38) {\n      if (this.isValidMove(0, -1)) {\n        this.updateGrid(this.unitTurn.pos[0], this.unitTurn.pos[1], 0);\n        this.updateGrid(\n          this.unitTurn.pos[0] - 1,\n          this.unitTurn.pos[1],\n          this.unitTurn\n        );\n        this.unitTurn.pos[0]--;\n        this.currentMoveCount--;\n      }\n    } else if (keyCode === 40) {\n      if (this.isValidMove(0, 1)) {\n        this.updateGrid(this.unitTurn.pos[0], this.unitTurn.pos[1], 0);\n        this.updateGrid(\n          this.unitTurn.pos[0] + 1,\n          this.unitTurn.pos[1],\n          this.unitTurn\n        );\n        this.unitTurn.pos[0]++;\n        this.currentMoveCount--;\n      }\n    }\n    if (this.currentMoveCount === 0) {\n      document.removeEventListener(\"keydown\", this.moveunit);\n      let counter = document.getElementById(\"moveCounter\");\n      counter.style.display = \"none\";\n      //add moveOptions\n      let moveOptions = document.getElementsByClassName(\"moveB\");\n      for (let i = 0; i < moveOptions.length; i++) {\n        moveOptions[i].style.display = \"block\";\n      }\n      move.style.display = \"none\";\n      return;\n    }\n    let counter = document.getElementById(\"moveCounter\");\n    counter.textContent = `Moves Left: ${this.currentMoveCount}`;\n  };\n\n  getCenter(w, h) {\n    return {\n      x: window.innerWidth / 2 - w / 2 + \"px\",\n      y: window.innerHeight / 2 - h / 2 + \"px\",\n    };\n  }\n\n  createUnitCanvas() {\n    let arr = [];\n    for (let i = 0; i < this.unitOrder.length; i++) {\n      let unit = document.createElement(\"canvas\");\n      unit.id = `${this.unitOrder[i].name}`;\n      let unitContext = unit.getContext(\"2d\");\n\n      document.body.appendChild(unit);\n      let container = document.getElementById(\"container\");\n      container.appendChild(unit);\n      arr.push(unitContext);\n    }\n    return arr;\n  }\n\n  drawBattlefield() {\n    this.canvas = document.getElementById(\"game\");\n    this.context = this.canvas.getContext(\"2d\");\n    // this.canvas.style.width = 680;\n    // this.canvas.style.height = 680;\n    // this.canvas.style.display = \"inline-block\";\n    // this.canvas.style.position = \"relative\";\n    this.canvas.style.background = color;\n    // this.canvas.style.right = \"190\";\n    // this.canvas.style.bottom = \"686\";\n\n    // document.body.appendChild(this.canvas);\n    // let container = document.getElementById(\"container\");\n    // container.appendChild(this.canvas);\n\n    return this.context;\n  }\n\n  generateHTMLsquares() {\n    for (let row = 0; row < this.grid.length; row++) {\n      for (let col = 0; col < this.grid[row].length; col++) {\n        let square = document.createElement(\"div\");\n        square.id = `${this.grid[row][col]}`;\n        square.className = \"square\";\n        square.style.position = \"absolute\";\n        square.style.top = row * (this.cellSize + this.padding);\n        square.style.left = col * (this.cellSize + this.padding);\n        square.style.width = this.cellSize;\n        square.style.height = this.cellSize;\n        // document.body.appendChild(square);\n        square.style.zIndex = 100;\n        // this.battlefield.canvas.appendChild(square);\n        let squares = document.getElementById(\"squares\");\n        squares.appendChild(square);\n      }\n    }\n  }\n\n  generateHTMLunits() {\n    for (let row = 0; row < this.unitGrid.length; row++) {\n      for (let col = 0; col < this.unitGrid[row].length; col++) {\n        if (this.unitGrid[row][col] instanceof Unit) {\n          let unitClick = document.createElement(\"div\");\n          unitClick.id = `${this.unitGrid[row][col].name}`;\n          unitClick.className = \"unit\";\n          unitClick.style.position = \"absolute\";\n          unitClick.style.top = row * (this.cellSize + this.padding);\n          unitClick.style.left = col * (this.cellSize + this.padding);\n          unitClick.style.width = this.cellSize;\n          unitClick.style.height = this.cellSize;\n          unitClick.style.zIndex = 101;\n          let squares = document.getElementById(\"squares\");\n          squares.appendChild(unitClick);\n        }\n      }\n    }\n  }\n\n  // renderUnits() {\n  //     for (let i = 0; i < this.unitOrder.length; i++) {\n  //         let unitContext = this.unitContexts[i];\n\n  //         const w = (this.cellSize + this.padding) * this.grid[0].length - (this.padding);\n  //         const h = (this.cellSize + this.padding) * this.grid.length - (this.padding);\n\n  //         unitContext.canvas.width = w;\n  //         unitContext.canvas.height = h;\n\n  //         const center = this.getCenter(w, h);\n  //         unitContext.canvas.style.marginLeft = center.x\n  //         unitContext.canvas.style.marginTop = center.y;\n\n  //         let image;\n  //         if (this.unitOrder[i].type === \"rifleman\") {\n  //             image = this.unitImages[0];\n  //         } else if (this.unitOrder[i].type === \"sniper\") {\n  //             image = this.unitImages[1];\n  //         } else if (this.unitOrder[i].type === \"atGunner\") {\n  //             image = this.unitImages[2];\n  //         }\n\n  //         unitContext.drawImage(image, 8, 8, 48, 48, this.unitOrder[i].pos[1] * (this.cellSize + this.padding), this.unitOrder[i].pos[0] * (this.cellSize + this.padding), this.cellSize, this.cellSize);\n  //     }\n  // }\n\n  render() {\n    const w =\n      (this.cellSize + this.padding) * this.grid[0].length - this.padding;\n    const h = (this.cellSize + this.padding) * this.grid.length - this.padding;\n\n    this.battlefield.canvas.width = w;\n    this.battlefield.canvas.height = h;\n\n    const center = this.getCenter(w, h);\n    this.battlefield.canvas.style.marginLeft = center.x;\n    this.battlefield.canvas.style.marginTop = center.y;\n\n    for (let row = 0; row < this.grid.length; row++) {\n      for (let col = 0; col < this.grid[row].length; col++) {\n        const val = this.grid[row][col];\n\n        let image;\n        let sx = 0;\n        let sy = 0;\n        if (val === 0) {\n          image = this.tiles[0];\n          sx = 144;\n          sy = 144;\n        } else if (val === 1) {\n          image = this.tiles[1];\n          sx = 144;\n          sy = 144;\n        } else if (val === 3) {\n          image = this.tiles[2];\n          sx = 1;\n          sy = 0;\n        }\n\n        //drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)\n        this.battlefield.drawImage(\n          image,\n          sx,\n          sy,\n          30,\n          30,\n          col * (this.cellSize + this.padding),\n          row * (this.cellSize + this.padding),\n          this.cellSize,\n          this.cellSize\n        );\n        //create corresponding html box element\n        //let boxElement = document.createElement('div');\n        // this.battlefield.canvas.style.width = this.cellSize;\n        // this.battlefield.canvas.style.height = this.cellSize;\n        let x;\n        let y;\n        let image2;\n        if (this.unitGrid[row][col] instanceof Unit) {\n          x = this.unitGrid[row][col].pos[1];\n          y = this.unitGrid[row][col].pos[0];\n          if (this.unitGrid[row][col].type === \"rifleman\") {\n            image2 = this.unitImages[0];\n          } else if (this.unitGrid[row][col].type === \"sniper\") {\n            image2 = this.unitImages[1];\n          } else if (this.unitGrid[row][col].type === \"atGunner\") {\n            image2 = this.unitImages[2];\n          }\n          this.battlefield.drawImage(\n            image2,\n            8,\n            8,\n            48,\n            48,\n            col * (this.cellSize + this.padding),\n            row * (this.cellSize + this.padding),\n            this.cellSize,\n            this.cellSize\n          );\n        }\n        // unitContext.drawImage(image, 8, 8, 48, 48, this.unitOrder[i].pos[1] * (this.cellSize + this.padding), this.unitOrder[i].pos[0] * (this.cellSize + this.padding), this.cellSize, this.cellSize);\n\n        // this.battlefield.fillStyle = color;\n        // this.battlefield.fillRect(col * (this.cellSize + this.padding),\n        // row * (this.cellSize + this.padding),\n        // this.cellSize, this.cellSize);\n      }\n    }\n  }\n\n  renderOptions() {\n    let context = document.getElementById(\"\");\n    let button1 = document.createElement(\"button\");\n    let button2 = document.createElement(\"button\");\n    let button3 = document.createElement(\"button\");\n    let button4 = document.createElement(\"button\");\n\n    button1.class = \"move\";\n    button2.class = \"attack\";\n    button3.class = \"items\";\n    button4.class = \"defend\";\n\n    button1.style.display = \"block\";\n  }\n\n  draw(name) {\n    let canvas = document.createElement(\"canvas\");\n    canvas.id = name;\n    let w = canvas.width;\n    let h = canvas.height;\n    let context = canvas.getContext(\"2d\");\n    document.body.appendChild(canvas);\n    //canvas.style.display = \"none\";\n    if (name === \"moveOptions\") {\n      this.renderOptions();\n    }\n    return this.context;\n  }\n\n  drawSquare(x, y, w, h, color) {\n    this.battlefieldContext.lineWidth = 1;\n    this.battlefieldContext.fillStyle = color;\n    this.battlefieldContext.fillRect(x, y, w, h);\n    this.battlefieldContext.strokeRect(x, y, w, h);\n  }\n\n  drawGrid() {\n    let x = 0;\n    let y = 0;\n    let w = this.squareSize;\n    let h = this.squareSize;\n\n    for (let i = 0; i < this.grid.length; i++) {\n      for (let j = 0; j < this.grid.length; j++) {\n        if (this.grid[i][j] === 0) {\n          this.drawSquare(x, y, w, h, \"#d3d3d2\");\n        } else {\n          this.drawSquare(x, y, w, h, \"#111\");\n        }\n        x += w;\n      }\n      y += h;\n      x = 0;\n    }\n  }\n\n  enemyAction() {\n    //ai functionality\n    //has to click end turn button\n  }\n\n  nextTurn() {\n    if (this.gameEnd()) {\n      //victory or loss screen\n    }\n    this.currentTurn++;\n    //console.log(count, 'count')\n    count.textContent = this.currentTurn + 1;\n    //have to update unit turn, because constructor only called once\n    this.unitTurn = this.unitOrder[this.currentTurn % this.unitOrder.length];\n    name.textContent = `${this.unitTurn.name}`;\n\n    if (this.unitTurn.type === null) {\n      this.enemyAction();\n    }\n    this.gameEnd();\n  }\n\n  gameEnd() {\n    if (this.currentTurn === 50) {\n      console.log(\"You lose!\");\n      return true;\n    }\n\n    if (this.won()) {\n      console.log(\"You win!\");\n      return true;\n    } else if (this.lost()) {\n      console.log(\"You lose!\");\n      return true;\n    }\n    return false;\n  }\n\n  removeUnit(unit) {\n    let index = this.unitOrder.indexOf(unit);\n    if (index > -1) {\n      this.unitOrder.splice(index, 1);\n    }\n    let x = unit.pos[0];\n    let y = unit.pos[1];\n    this.unitGrid[x][y] = 0;\n    if (unit.owner === null) {\n      this.enemies.splice(this.enemies.indexOf(unit), 1);\n    } else {\n      this.units.splice(this.units.indexOf(unit), 1);\n    }\n\n    let deadUnit = document.getElementById(unit.name);\n    deadUnit.remove();\n    this.gameEnd();\n    this.savePositions();\n    this.nextTurn();\n    this.setCurrentMoveCount();\n    let move = document.getElementById(\"move\");\n    move.style.display = \"block\";\n    let moveOptions = document.getElementsByClassName(\"moveB\");\n    for (let i = 0; i < moveOptions.length; i++) {\n      moveOptions[i].style.display = \"block\";\n    }\n  }\n\n  // attack(pos) {\n  //     let x = pos[0];\n  //     let y = pos[1];\n\n  //     if (this.grid[x][y] instanceof Unit && this.grid[x][y].type === null) {\n  //         this.grid[x][y].takeDamage(this.unitTurn.attack);\n  //         if (this.grid[x][y].alive === false) {\n  //             this.removeUnit(this.grid[x][y]);\n  //         }\n  //         return true;\n  //     }\n  //     return false;\n  // }\n\n  moveUnit(pos) {\n    let x = pos[0];\n    let y = pos[1];\n    let current = this.unitTurn.pos;\n    let newPos = [current[0] + x, current[1] + y];\n    if (this.validMove(newPos)) {\n      this.unitTurn.move(newPos);\n      if (this.unitTurn.owner != null) {\n        this.grid[newPos[0]][newPos[1]] = this.unitTurn;\n      }\n      return true;\n    }\n    return false;\n  }\n\n  validMove(pos) {\n    let x = pos[0];\n    let y = pos[1];\n    if (x > 9 || x < 0 || y > 9 || y < 0) {\n      return false;\n    }\n    if (this.grid[x][y] !== 1 || this.grid[x][y] !== 0) {\n      return false;\n    }\n    return true;\n  }\n\n  won() {\n    if (this.enemies.length === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  lost() {\n    if (this.units.length === 0) {\n      return true;\n    }\n    return false;\n  }\n\n  setTurnOrder() {\n    let arr = [];\n    let unitCount = 0;\n    let enemyCount = 0;\n    for (let i = 0; i < this.units.length + this.enemies.length; i++) {\n      if (i % 2 === 0) {\n        arr.push(this.units[unitCount]);\n        unitCount++;\n      } else {\n        arr.push(this.enemies[enemyCount]);\n        enemyCount++;\n      }\n    }\n    console.log(arr);\n    return arr;\n  }\n\n  shuffleArray(array) {\n    let i = array.length;\n    let rand = i;\n    while (i >= 0) {\n      rand = Math.floor(Math.random() * (i + 1));\n      let temp = array[i];\n      array[i] = array[rand];\n      array[rand] = temp;\n      i--;\n    }\n    return array;\n  }\n\n  renderStatus() {}\n\n  // createObjectGrid() {\n  //     let newGrid = [...Array(10)].map(e => Array(10));\n  //     for (let i = 0; i < this.grid.length; i++) {\n  //         for (let j = 0; j < this.grid.length; j++) {\n  //             if (this.grid[i][j] === 0) {\n  //                 newGrid[i][j].push(new Plain());\n  //             } else if (this.grid[i][j] === 1) {\n  //                 newGrid[i][j].push(new Wall());\n  //             } else if (this.grid[i][j] === 2) {\n  //                 newGrid[i][j].push();\n  //             } else if (this.grid[i][j] === 3) {\n  //                 newGrid[i][j].push();\n  //             } else if (this.grid[i][j] === 4) {\n  //                 newGrid[i][j].push();\n  //             } else {\n  //                 newGrid[i][j].push();\n  //             }\n  //         }\n  //     }\n  //     return newGrid;\n  // }\n}\n\nexport default Board;\n"],"names":["Unit","require","module","exports","constructor","name","owner","super","this","BATTLEFIELDS","levelOne","levelTwo","type","playerUnits","assignUnits","units","concat","health","attack","defense","range","move","alive","items","pos","setAlive","status","setPiece","newPos","giveItem","item","push","isAlive","takeDamage","dmg","console","log","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","g","globalThis","Function","e","window","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","length","Error","replace","p","querySelector"],"sourceRoot":""}